package ui;

import java.util.ArrayList;
import java.util.List;

import algo.*;
import javafx.animation.Interpolator;
import javafx.animation.ParallelTransition;
import javafx.animation.RotateTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Transition;
import javafx.animation.TranslateTransition;
import javafx.application.Application;
import javafx.geometry.Point2D;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.SnapshotParameters;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
import javafx.util.Duration;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Translate;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.ImagePattern;
import javafx.scene.paint.RadialGradient;
import javafx.scene.paint.Stop;

public class Simulator extends Application {
	
	double width = 200;
	double height = 200;
	double scaling = 4;
	
	public static void main(String[] args) {
        launch();
    }

    @Override
    public void start(Stage primaryStage) {
    	
    	Pane pane = new Pane();
    	
    	Scene scene = new Scene(pane, width * scaling, height * scaling);
    	
    	Map testMap = new Map();
//         Set test obstacles.
        testMap.setObstacle(13, 14, 'E');
        testMap.setObstacle(18, 2, 'N');
        testMap.assignNodeNumbers();
        testMap.printMap();
        
    	List<Obstacle> obstacleList = new ArrayList<Obstacle>();  //Match with the obstacles in map, order matters, it is the order of the obstacles that the robot visits
    	obstacleList.add(new Obstacle(13, 14, 'E'));
    	obstacleList.add(new Obstacle(18, 2, 'N'));
		
		placeObstacles(obstacleList, pane);		//Adds obstacles to the GUI
		
        List<Cell> testPath = new ArrayList<Cell>();	//Replace with A star algorithm that generates a list of list of cells
        List<Cell> testPath2 = new ArrayList<Cell>();
        
        testPath.add(new Cell(5, 10));
        testPath.add(new Cell(5, 11));
        testPath.add(new Cell(5, 12));
        testPath.add(new Cell(5, 13));
        testPath.add(new Cell(5, 14));
        testPath.add(new Cell(6, 14));
        testPath.add(new Cell(7, 14));
        testPath.add(new Cell(8, 14));
        testPath.add(new Cell(9, 14));
        testPath.add(new Cell(10, 14));
        testPath.add(new Cell(11, 14));
        testPath.add(new Cell(11, 15));
        testPath.add(new Cell(11, 16));     
        testPath.add(new Cell(12, 16));
        testPath.add(new Cell(13, 16));
        testPath.add(new Cell(14, 16));
        testPath.add(new Cell(15, 16));
        testPath.add(new Cell(16, 16));
        testPath.add(new Cell(17, 16));
        testPath.add(new Cell(18, 16));
        testPath.add(new Cell(18, 15));
        testPath.add(new Cell(18, 14));
        
        testPath2.add(new Cell(18, 14));
        testPath2.add(new Cell(18, 13));
        testPath2.add(new Cell(18, 12));
        testPath2.add(new Cell(18, 11));
        testPath2.add(new Cell(18, 10));
        testPath2.add(new Cell(18, 9));
        testPath2.add(new Cell(18, 8));
        testPath2.add(new Cell(18, 7));
        
        List<List<Cell>> aPath = new ArrayList<List<Cell>>();         //This should be generated by the A star algo, for now I just hard code the path that the robot will travel
        aPath.add(testPath);
        aPath.add(testPath2);	
        
        Robot robot = new Robot(2, 10, 'W');         //Not needed by my pathing function
        
        robot.centerX = 25;               //My pathing function requires the center point of the robot which I set here as the starting point
        robot.centerY = 105;
        robot.setDirection('W');
        
		UIRobot uiRobot = new UIRobot(pane, height, scaling, 'W', 25, 105);      //Creates a robot version to be placed into the GUI		
        	
		uiRobot.executeCommands(aPath, robot, testMap, obstacleList);      //Plays the animated path
		
        primaryStage.setTitle("Simulator");
        primaryStage.setScene(scene);
        primaryStage.show();
               
        scene.setFill(createGridPattern());
    }
    
    public ImagePattern createGridPattern() {

        double w = 40;
        double h = 40;

        Canvas canvas = new Canvas(w, h);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        gc.setStroke(Color.BLACK);
        gc.setFill(Color.valueOf("#bee1ed"));
        gc.fillRect(0, 0, w, h);
        gc.strokeRect(0.5, 0.5, w, h);
        
        Image image = canvas.snapshot(new SnapshotParameters(), null);
        ImagePattern pattern = new ImagePattern(image, 0, 0, w, h, false);

        return pattern;

    }
    
    public void placeObstacles(List<Obstacle> obstacleList, Pane pane)  
    {  	  	
    	for(Obstacle obstacle : obstacleList)
    	{
    		int x = obstacle.getX() * 10;
    		int y = obstacle.getY() * 10;
    		Rectangle obstacleRectangle = new Rectangle();
    		obstacleRectangle.setX(x * scaling);
    		obstacleRectangle.setY((height - 10 - y) * scaling);
    		obstacleRectangle.setWidth(10 * scaling);
    		obstacleRectangle.setHeight(10 * scaling);
    		pane.getChildren().add(obstacleRectangle);
    		
    		char direction = obstacle.getDirection();
    		
    		Line line = new Line();
    		
    		switch(direction)
    		{
	    		case 'N':
	    			line.setStartX((x + 1) * scaling);
	    			line.setEndX((x + 9) * scaling);
	    			line.setStartY((height - 10 - y) * scaling);
	    			line.setEndY((height - 10 - y) * scaling);
	    			line.setStroke(Color.RED);
	    			line.setStrokeWidth(scaling + 1);
	    			break;
	    		case 'S':
	    			line.setStartX((x + 1) * scaling);
	    			line.setEndX((x + 9) * scaling);
	    			line.setStartY((height - y) * scaling);
	    			line.setEndY((height - y) * scaling);
	    			line.setStroke(Color.RED);
	    			line.setStrokeWidth(scaling + 1);
	    			break;
	    		case 'E':
	    			line.setStartX((x + 10) * scaling);
	    			line.setEndX((x + 10) * scaling);
	    			line.setStartY((height - 1 - y) * scaling);
	    			line.setEndY((height - 9 - y) * scaling);
	    			line.setStroke(Color.RED);
	    			line.setStrokeWidth(scaling + 1);
	    			break;
	    		case 'W':
	    			line.setStartX((x) * scaling);
	    			line.setEndX((x) * scaling);
	    			line.setStartY((height - 1 - y) * scaling);
	    			line.setEndY((height - 9 - y) * scaling);
	    			line.setStroke(Color.RED);
	    			line.setStrokeWidth(scaling + 1);
	    			break;
    		}
    		
    		pane.getChildren().add(line);
    	}
    }   
}